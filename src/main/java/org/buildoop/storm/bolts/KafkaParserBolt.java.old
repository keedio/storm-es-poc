package org.buildoop.storm.bolts;

import backtype.storm.task.TopologyContext;
import backtype.storm.topology.BasicOutputCollector;
import backtype.storm.topology.IBasicBolt;
import backtype.storm.topology.OutputFieldsDeclarer;
import backtype.storm.tuple.Fields;
import backtype.storm.tuple.Tuple;

import java.util.Date;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Map;

import static backtype.storm.utils.Utils.tuple;

@SuppressWarnings("serial")
public class KafkaParserBolt implements IBasicBolt {
	
	private String index;
	private int id=1000;
	//private String type;

	@SuppressWarnings("rawtypes")
    public void prepare(Map stormConf, TopologyContext context) {
    	index = (String) stormConf.get("elasticsearch.index");
    	//this.type = (String) stormConf.get("elasticsearch.type");
    }

    public void execute(Tuple input, BasicOutputCollector collector) {
    	String kafkaEvent = new String(input.getBinary(0));
    	
    	
    	if (kafkaEvent.length()>0)
    	{
    		String[] line = kafkaEvent.split(",");
    		String time = "";
    		
        	System.out.println(kafkaEvent);
        	DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    		
    		String document;
    		
    		
    		document = "{";
    		    		
    		try{
    			
    			/*
				doc.put(new Text("transaction_date"), new Text(transformDate(field[0], "d/M/yy H:mm", "yyyy-MM-dd'T'HH:mm:ss.SSSZ")));
				doc.put(new Text("product"), new Text(field[1]));
				doc.put(new Text("price"), new Text(field[2]));
				doc.put(new Text("payment_type"), new Text(field[3]));
				doc.put(new Text("name"), new Text(field[4]));
				doc.put(new Text("city"), new Text(field[5]));
				doc.put(new Text("state"), new Text(field[6]));
				doc.put(new Text("country"), new Text(field[7]));
				doc.put(new Text("account_created"), new Text(transformDate(field[8], "d/M/yy H:mm", "yyyy-MM-dd'T'HH:mm:ss.SSSZ")));
				doc.put(new Text("last_login"), new Text(field[9]));
				doc.put(new Text("latitude"), new Text(field[10]));
				doc.put(new Text("longitude"), new Text(field[11]));
    			 */
    			
    		time = transformDate(line[0], "d/M/yy H:mm", "yyyyDDDâ€™T'HHmmssZ");
    		document = document+"\"transaction_date\":\""+time+"\",";
    		
    		document = document+"\"product\":\""+line[1]+"\",";
    		
    		document = document+"\"price\":"+line[2]+",";
    		
    		document = document+"\"payment_type\":\""+line[3]+"\",";
    		
    		document = document+"\"name\":\""+line[4]+"\",";
    		
    		document = document+"\"city\":\""+line[5]+"\",";
    		
    		document = document+"\"state\":\""+line[6]+"\",";
    		
    		document = document+"\"country\":\""+line[7]+"\",";
    		
    		document = document+"\"latitude\":\""+line[10]+"\",";
    		
    		document = document+"\"longitude\":\""+line[11]+"\"";
    		
    		document = document+"}";

    		
        	System.out.println("key:"+time);
        	System.out.println("index:"+index);
        	System.out.println("document:"+document);
    		} catch (Exception e) {
    			e.printStackTrace();
    		}
        	
        	collector.emit(tuple("" + id++,index, "product", document));
    	}
    	
    	
    	
		
    }

    
	private static String transformDate(String date, String originPtt, String finalPtt) {
		try {
		SimpleDateFormat sdf1 = new SimpleDateFormat(originPtt);
		Date date1 = sdf1.parse(date);
		
		SimpleDateFormat sdf2 = new SimpleDateFormat(finalPtt);
		
		return sdf2.format(date1);
		} catch (Exception e) {
			return "";
		}
		
	}
    
    
	public void cleanup() {

    }

    public void declareOutputFields(OutputFieldsDeclarer declarer) {
        declarer.declare(new Fields("id", "index", "type", "document"));
    }

    @Override
    public Map<String, Object> getComponentConfiguration() {
        return null;
    }
    

}
